#! /usr/bin/env python
"""
createOutputSpecs 

Creates the Json output specification file.

COPYRIGHT: 2016, University Corporation for Atmospheric Research
LICENSE: See the LICENSE.rst file for details
"""

import argparse, os
import json
from pyconform import miptableparser
from dateutil.parser import parse
import datetime

data_types = {'char': 'char', 'byte': 'int8', 'short': 'int16', 'int': 'int32',
              'float': 'float32', 'real': 'float32', 'double': 'float64', 'integer':'int32'}


#===================================================================================================
# parseArgs
#===================================================================================================
def parseArgs(argv=None):

    desc = "This tool creates a specification file that is needed to run PyConform."

    parser = argparse.ArgumentParser(prog='createOutputSpecs', description=desc)
    parser.add_argument('-d', '--defFile', default=None, type=str, required=True,
                        help='A file listing the variable definitions.')
    parser.add_argument('-g', '--globalAttrFile', default=None, type=str,
                        help='A file listing the global attributes that are common to all files.')
    parser.add_argument('-e', '--exp', default=None, type=str,
                        help='The name of the experiment.')
    parser.add_argument('-m', '--mipTable', default=None, type=str,
                        help='The name of the MIP table.')
    parser.add_argument('-tt', '--mipTableType', default=None, type=str,
                        help='MIP table file type.  Can be xml, cmor, or excel.')
    parser.add_argument('-u', '--userList', default=None, type=str,
                        help='A file containing cf-compliant names to derive.')
    parser.add_argument('-o', '--outputpath', default=os.getcwd(), type=str,
                        help='Output pathname for the output specification file(s).')

    return parser.parse_args(argv)


#===================================================================================================
# load
#===================================================================================================
def load(defs):

    def_dict = {}
    for line in defs:
        split = line.split('=')
        if (len(split) == 2):
            def_dict[split[0].strip()] = split[1].strip()
        else:
            if line != '\n':
                print 'Could not parse this line: ', line
    return def_dict


#===================================================================================================
# create_output
#===================================================================================================
def create_output(table_dict, id, definitions, attributes, output_path, args):

    outSpec = {}
    variables = {}
    axes = {}
    table_info = {}

    variables = table_dict['variables']
    axes = table_dict['axes']
    table_info = table_dict['table_info']
    attributes.update(table_info)
    if 'generic_levels' in table_info:
        g_levels = table_info['generic_levels']
        g_split = g_levels.split(' ')
        for l in g_split:
            axes[l] = {}

    # Get variables needed to piece together the filename
    identifier = id
    if ('model_id') in attributes:
        model = attributes['model_id']
    else:
        model = ''
    experiment = args.exp
    ripgf_list = ['realization_index', 'initialization_index', 'physics_index',
                  'forcing_index', 'grid_index']
    if all (ripgf in attributes for ripgf in ripgf_list):
        ripfg = ("r{0}i{1}p{2}f{3}g{4}".format(attributes['realization_index'],
                                               attributes['initialization_index'],
                                               attributes['physics_index'],
                                               attributes['forcing_index'],
                                               attributes['grid_index']))
    else:
        ripfg = ''
    table = identifier
    today = datetime.datetime.now()
    version = 'v' + str(today.year).zfill(4) + str(today.month).zfill(2) + str(today.day).zfill(2)

    # Do we need to add anything to further_info_url?
    if 'further_info_url' in attributes:
        fiu_split = str(attributes['further_info_url']).split('/')
        if table not in fiu_split:
            attributes['further_info_url'] = str(attributes['further_info_url']) + '/' + table
        if experiment not in fiu_split:
            attributes['further_info_url'] = str(attributes['further_info_url']) + '/' + experiment

    # Create Output Spec
    # First add global attributes that are common to all files
    outSpec["attributes"] = attributes

    var_list = {}

    # For each variable in the definition file, create a file entry in the spec and define it
    for v, d in variables.iteritems():
        if v in definitions:
            tper = variables[v]['frequency']
            component = variables[v]['modeling_realm']
            if ' ' in component:
                component = component.replace(' ', '_')
            f_name = ("{0}/{1}/{2}/{3}/{4}/{5}/{6}/{7}_{8}_{9}_{10}_{11}".format(experiment,
                       tper, component, table, ripfg, version, v,
                       v, table, model, experiment, ripfg))
            f_id = v
            var = {}
            for k1, v1 in variables[v].iteritems():
                if not isinstance(v1, (list, str, float)):
                    variables[v][k1] = "None"
            var["attributes"] = variables[v]
            var["definition"] = definitions[v]
            var["filename"] = f_name
            if 'type' in variables[v] and variables[v]['type'] != 'None' and variables[v]['type'] != '':
                var["datatype"] = data_types[variables[v]['type']]
            else:
                var["datatype"] = 'None'
            if 'requested' in variables[v]:
                if variables[v]['requested'] != '':
                    var['data'] = variables[v]['requested']
            if 'dimensions' in variables[v]:
                var["dimensions"] = variables[v]['dimensions'].split('|')
            var_list[f_id] = var

    # Add axes into the variable list
    for v, d in axes.iteritems():
        f_id = v
        var = {}
        var["attributes"] = axes[v]
        if 'type' in axes[v]:
            var["datatype"] = data_types[axes[v]['type']]
        if 'requested' in axes[v]:
            if axes[v]['requested'] != '':
                var['data'] = axes[v]['requested']
        var_list[f_id] = var

    # Go through a user supplied list if specified
    if args.userList and os.path.isfile(args.userList):
        with open(args.userList) as f:
            for vr in f:
                vr = vr.strip()
                if vr != "":
                    var = {}
                    f_id = vr
                    if vr in definitions:
                        var["attributes"] = {}
                        var["definition"] = definitions[vr]
                        f_name = ("{0}{1}".format(vr, fn_suffix))
                        var["filename"] = f_name
                        var["datatype"] = "None"
                        var["dimensions"] = "None"
                        var_list[f_id] = var
                    else:
                        print ('{} is being requested by the experiment, but a definition has not '
                               'been supplied.').format(vr)
    else:
        if args.userList and not os.path.isfile(args.userList):
            print 'The User Variable List file does not exist: ', args.userList
            os.sys.exit(1)

    outSpec["variables"] = var_list

    # Write the JSON output spec file
    f = output_path + '/' + experiment + '_' + id + '_spec.json'
    if not os.path.exists(output_path):
        os.makedirs(output_path)
    with open(f, 'w') as outfile:
        json.dump(outSpec, outfile, sort_keys=True, indent=4)



def main(argv=None):

    args = parseArgs(argv)

    print
    print "------------------------------------------"
    print 'Running createOutputSpecs with these args:'
    print
    print 'Variable Definitions: ', args.defFile
    print 'Global Attributes to be added to each file: ', args.globalAttrFile
    print 'Experiment Name: ', args.exp
    print 'MIP Table to be used: ', args.mipTable
    print 'MIP Table Type: ', args.mipTableType
    print 'User supplied variable list: ', args.userList
    print 'Will create output spec files within this directory:', args.outputpath
    print "------------------------------------------"

    # Open/Read the definition file
    if os.path.isfile(args.defFile):
        with open(args.defFile) as y_definitions:
            definitions = load(y_definitions)
    else:
        print 'Definition file does not exist: ', args.defFile
        os.sys.exit(1)

    # Open/Read the global attributes file
    attributes = {}
    if args.globalAttrFile and os.path.isfile(args.globalAttrFile):
        with open(args.globalAttrFile) as y_attributes:
            attributes = load(y_attributes)
    else:
        if args.globalAttrFile and not os.path.isfile(args.globalAttrFile):
            print 'Global Attributes file does not exist: ', args.globalAttrFile
            os.sys.exit(1)

    # Open/Read the MIP table
    if args.mipTableType != None and args.exp != None:
        exp_dict = miptableparser.parse_mip_table(args.exp, args.mipTable,
                                                  table_type=args.mipTableType)

    # Write the spec files out to disk
    for t in exp_dict:
        create_output(exp_dict[t], t, definitions, attributes, args.outputpath, args)


#===================================================================================================
# COMMAND-LINE OPERATION
#===================================================================================================
if __name__ == '__main__':
    main()
